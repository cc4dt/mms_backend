"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTimeUtc @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTimeUtc")

""
scalar JSON @scalar(class: "MLL\\GraphQLScalars\\JSON")

type Query {
    me: User @auth

    users(ids: [Int!] @in(key: "id"), level_id: USERLEVEL @eq): [User!]! @paginate(defaultCount: 10) # @all
    user(id: ID! @eq): User @find
    usersById(ids: [Int!] @in(key: "id"), level_id: USERLEVEL @eq): [User!]! @paginate(defaultCount: 10) # @all


    userLevels: [ConstField!]! @field(resolver: "MasterQuery@userLevels")
    ticketStatus: [TicketStatus!]! @all
    ticketTypes: [TicketType!]! @all
    ticketTrades: [TicketTrade!]! @all
    ticketPriorities: [TicketPriority!]! @all
}

extend type Query @guard {
    # masterEquipment(id: ID): [MasterEquipment!] @field(resolver: "MasterQuery@masterEquipment")
    masterEquipment(equipment_id: ID @eq, station_id: ID @eq): [MasterEquipment!] @all
    part(id: ID! @eq): Part! @find

    dashboard: Dashboard! @field(resolver: "DashQuery")
    teamleaders: [User!]! @field(resolver: "UserQuery@teamleaders")

    ticket(id: ID! @eq): Ticket @find
    tickets: [Ticket!]! 
     @paginate(defaultCount: 10)
     @orderBy(column: "updated_at", direction: DESC)

    state: [State!]! @find
    allStates: [State!]! @all
    paginateStates: [State!]! @paginate(defaultCount: 10)

    equipment(id: ID! @eq): Equipment! @find
    allEquipment: [Equipment!]! @all
    paginateEquipment: [Equipment!]! @paginate(defaultCount: 10)
}

input OrderByClause{
    field: String!
    order: SortOrder!
}

enum SortOrder {
    ASC
    DESC
}

type SLA {
    key: String!
    name: String!
    count: Int!
    percentage: Float!
}

type StatusReported {
    id: ID!
    name: String!
    count: Int!
    percentage: Float!
}

type TopReported {
    id: ID!
    name: String!
    topCount: Int!
}

type TopReportedStation {
    id: ID!
    name: String!
    topCount: Int!

}

type Dashboard {
    topReported: [TopReported!]!
    topReportedStation: [TopReportedStation!]!
    sla: [SLA!]!
    statusReported: [StatusReported!]!
}

type User {
    id: ID!
    name: String!
    email: String!
    level: ConstField!
    notifications: [Notification!]!  @morphMany(type: PAGINATOR)
    created_at: DateTimeUtc
    updated_at: DateTimeUtc
}

enum USERLEVEL {
  ADMIN @enum(value: 1)
  SUPERVISOR @enum(value: 2)
  TEAMLEADER @enum(value: 3)
  CLIENT @enum(value: 4)
}

type Notification {
    id: ID!
    type: String!
    data: JSON
    read_at: DateTimeUtc
}

type ConstField {
    key: String
    value: String
}

type TicketType {
    id: ID!
    key: String!
    name: String!
}

type TicketTrade {
    id: ID!
    key: String!
    name: String!
}

type TicketPriority {
    id: ID!
    key: String!
    name: String!
}

type TicketStatus {
    id: ID!
    key: String!
    name: String!
}

type Ticket {
    id: ID!
    number: String!
    state: State!
    station: Station!
    equipment: Equipment!
    breakdown: Breakdown!
    open_description: String
    type: TicketType
    trade: TicketTrade
    priority: TicketPriority
    work_description: String
    status: TicketStatus!
    teamleader: User
    maintenance_processes: [MaintenanceProcess!]  @hasMany
    created_by: User
    updated_by: User
    created_at: DateTimeUtc
    updated_at: DateTimeUtc
}

type MaintenanceProcess {
    id: ID!
    equipment: MasterEquipment
    part: Part!
    details: [MaintenanceDetail!]
}

type MasterEquipment {
    id: ID!
    equipment: Equipment!
    station: Station!
    serial: String
    details: [MasterDetail!]
}

type MasterDetail {
    id: ID!
    attribute: Attribute!
    value: String!
}

type Part {
    id: ID!
    name: String!
    equipment: Equipment!
    sub_parts: [SubPart!]
    attributes: [Attribute!]
}

type Attribute {
    id: ID!
    name: String!
    type: ConstField!
}

type SubPart {
    id: ID!
    name: String!
}

type MaintenanceDetail {
    id: ID!
    sub_part: SubPart
    attribute: Attribute!
    value: String!
}

type State {
    id: ID!
    name: String!
    stations: [Station!]!
}

type Station {
    id: ID!
    name: String!
    state: State!
}

type Equipment {
    id: ID!
    name: String!
    breakdowns: [Breakdown!]!
    attributes: [Attribute!]!
    parts: [Part!]!
}

type Breakdown {
    id: ID!
    name: String!
    equipment: Equipment!
}

#########################################################


type Mutation {
    login(input: LoginInput!): Login
        @field(resolver: "AuthMutator@login")
        
    changePassword(old_password: String!, new_password: String!, confirm_password: String!): Boolean!
        @guard
        @field(resolver: "AuthMutator@changePassword")
        
    notificationsAsRead: Boolean!
        @guard
        @field(resolver: "NotificationsMutator@asRead")

    openTicket(input: OpenTicketInput!): Ticket
        @guard
        @field(resolver: "TicketMutator@open")

    assignTicket(id: ID!, input: AssignTicketInput!): Ticket
        @guard
        @field(resolver: "TicketMutator@assign")

    closeTicket(id: ID!, input: CloseTicketInput!): Ticket
        @guard
        @field(resolver: "TicketMutator@close")
}

input LoginInput {
    email: String!
    password: String!
    fcmToken: String!
    deviceName: String! 
    deviceType: String!
}

input OpenTicketInput {
    state_id: ID!
    station_id: ID!
    equipment_id: ID!
    breakdown_id: ID!
    open_description: String
}

input AssignTicketInput {
    teamleader_id: ID!
    type_id: ID!
    trade_id: ID!
    priority_id: ID!
    work_description: String
}

input CloseTicketInput {
    equipment_id: ID
    part_id: ID!
    status_id: ID
    details: [DetailTicketInput!]
}

input DetailTicketInput {
    sub_part_id: ID
    attribute_id: ID!
    value: String!
}

type Login {
    tokenType: String!
    token: String!
    deviceName: String!
    me: User!
}

#################################################

# type Subscription {
#   newTicketOpened(author: ID): Ticket!
# }
